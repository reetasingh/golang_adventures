package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"reflect"

	"golang.org/x/exp/maps"
)

func processTag(tag reflect.StructTag) {
	val := tag.Get("json")
	fmt.Println(val)
}

func convertTag(tag reflect.StructTag) reflect.StructTag {
	val := tag.Get("json")
	s := fmt.Sprintf(`db:"%s"`, val)
	newDBTag := reflect.StructTag(s)
	return newDBTag
}

// CreateDynamicStruct creates a new struct type dynamically based on the fields of the source type
func CreateDynamicStruct(sourceType reflect.Type) map[string]reflect.Type {
	numFields := sourceType.NumField()
	fieldTypes := make([]reflect.StructField, numFields)
	structMap := make(map[string]reflect.Type)
	currStructName := fmt.Sprintf("Dynamic%s", sourceType.Name())

	for i := 0; i < numFields; i++ {
		field := sourceType.Field(i)
		if field.Type.Kind().String() == "struct" {
			result := CreateDynamicStruct(field.Type)
			maps.Copy(structMap, result)
			//lastStruct := childStruct[len(childStruct)-1]
			fieldTypes[i] = reflect.StructField{
				Name: field.Name,
				Type: field.Type,
			}
		} else {
			fieldTypes[i] = reflect.StructField{
				Name: field.Name,
				Type: field.Type,
				Tag:  convertTag(field.Tag),
			}
		}
	}
	newStructType := reflect.StructOf(fieldTypes)
	structMap[currStructName] = newStructType
	return structMap
}

type InnerStruct struct {
	Field3 int `json:"field3,omitempty"`
	I      InnerInnerStruct
}

type InnerInnerStruct struct {
	Field4 int `json:"field4,omitempty"`
}

// SourceStruct represents the source struct
type SourceStruct struct {
	Field1 int    `json:"field1,omitempty"`
	Field2 string `json:"field2,omitempty"`
	Child  InnerStruct
}
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) generate(i any) map[string]reflect.Type {
	// Get the reflect.Type of SourceStruct
	sourceType := reflect.TypeOf(i)

	// Dynamically create a new struct type based on the fields of SourceStruct
	allStructs := CreateDynamicStruct(sourceType)

	// Create an instance of the dynamically created struct type
	//newStructValue := reflect.New(newStructType).Elem()
	return allStructs
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) writeStruct(name string, newStructType reflect.Type) {
	g.Printf(`type %s struct { `, name)
	for i := 0; i < newStructType.NumField(); i++ {
		field := newStructType.Field(i)
		g.Printf("\n")
		g.Printf(" %s %s", field.Name, field.Type)
		if field.Tag != "" {
			g.Printf(" `%s`", field.Tag)
		}
	}
	g.Printf("\n")
	g.Printf("}")
	g.Printf("\n")
}

func main() {
	g := Generator{}
	resultTypes := g.generate(SourceStruct{})
	// Print the type of the dynamically created struct
	//fmt.Printf("Type: %T\nValue: %+v\n", newStructValue.Interface(), newStructValue.Interface())
	g.Printf("// Code auto generated by \"generator dbstruct\"; DO NOT EDIT.\n")
	g.Printf(`package dbstruct`)
	g.Printf("\n")
	for k, v := range resultTypes {
		g.writeStruct(k, v)
	}

	src := g.format()
	err := os.WriteFile("dbstruct_models.go", src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}
